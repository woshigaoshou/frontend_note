### 一、 概念

- 时间复杂度：根据算法效率而定，常见的有O(1)、O($N$)、O($N^2$)、O($\log_xN$)等。

  + 算法：忽略常数，取最高项系数。


  + $log_aN$ = $loga_b$ * $logbN$  值相差一个常数，所以时间复杂度相同

- 空间复杂度：数据规模为N，需要多开一个辅助的数组，则空间复杂度为 O(N)

- 数据规模：1s内 O($N$)复杂度可运行$10^8$ 规模数据，O($N^2$) 可运行$10^4$ 规模数据，O($\log_xN$)可运行 $10^7$ 规模数据

- 均摊复杂度：`vector`每次resize扩大一倍的空间，执行n次赋值，但之前每一次都只执行一次代码，均摊到之前则为每一行代码执行$(n+n)/n = 2$，此时仍是`O(1)`级别的时间复杂度。但缩小数组时不能为$1/2$时就缩小，否则当在中间点重复删除添加会造成复杂度震荡（`O(1)`级别的算法退化为`O(N)`级别），此时最好的方法是在$1/4$时才进行缩小

  ```c++
  // 每个递归函数复杂度为T，深度为depth，总体时间复杂度为O(T * depth)
  int binarySearch(int arr[], int l, int r, int target){
    if (l > r) return -1;
    int mid = l + (r - l) / 2;
    if (arr[mid] === target) return mid;
    else if (arr[mid] > target) return binarySearch(arr, l, mid - 1, target);
    else return binarySearch(arr, mid + 1, r, target);
  }

  // 递归深度logn，时间复杂度为O(logn)
  double pow(double x, int n) {
    assert(n >= 0);
    if (n == 0) return 1.0;
    double t = pow(x, n/2);
    if (n % 2) return x * t * t;
    return t * t;
  }

  // 每次递归分裂为2个函数，时间复杂度为O(2^n)
  int f(int n) {
    assert(n >= 0);
    if (n == 0) return 1;
    return f(n-1) + f(n-1);
  }
  ```

- 时间复杂度效率对比：

  ![时间复杂度](E:\前端学习\frontend_note\图\时间复杂度.jpg)


### 二、小技巧

+ 确定每个变量的意义以及范围(开区间和闭区间)
+ 循环不变量(每次循环需要变量的取值，但不改变含义)
+ 小数据量调试 -> 大数据量调试
+ 判断数组是否越界
+ 确定题目条件进行剪枝

### 三、数学知识

- 排列种类为：$n!/(n - m)!$
- 组合的种类为：$n!/((n - m)! * m!)$

### 三、算法分类

1. 排序算法：
   - 有序：优先用二分查找
   - 求第K大的值：堆排序或者选择性快排(每次舍弃不满足的另外一半)
   - 三种不同的值：三路快排
   - 有序的两个数组合并：归并排序
2. 数组：
   + 双指针：利用慢指针和快指针，快指针遍历数组，慢指针内的范围满足题解，需要确定循环不变量以及变量的范围
   + 滑动窗口：设置双指针，通过指针不断调整窗口，对已经不满足条件的集合的子集也一起剪枝，最终达到O($N$)，适合取连续的子集
3. 查找表
   + Set：求集合
   + Map：记录次数
4. 链表：
   + 多存储指针，保存信息进行操作节点，
   + 通过建立一个虚拟节点，避免left为1的讨论（添加虚拟节点后，left最小为2）
   + 双指针：通常用于解决需要拿到倒数第N个节点的问题，定义p,q两个节点，让p和q的距离保持为n，判断q.next是否为空，则p为倒数第N个节点，q为最后一个节点
   + 快慢指针：slow每次走一步，fast每次走两步，若有相交则形成闭环，取中点时也可用快慢指针