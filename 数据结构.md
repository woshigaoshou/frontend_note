## 数据结构

### 一、栈

1. 特点：后进先出（LIFO）

2. 应用：函数调用栈、十进制转二进制

3. 实现：

   ```js
   function Stack() {
     this.items = [];
     // 将元素压入栈
     Stack.prototype.push = function(element) {
       this.items.push(element);
     }
     // 弹出栈顶元素
     Stack.prototype.pop = function() {
       return this.items.pop();
     }
     // 返回栈顶元素
     Stack.prototype.peek = function() {
       const lastIndex = this.items.length - 1;
       return this.items[lastIndex];
     }
     // 判断栈是否为空
     Stack.prototype.isEmpty = function() {
       return this.items.length === 0;
     }
     // 获取栈中元素个数
     Stack.prototype.size = function() {
       return this.items.length;
     }
     // toString方法
     Stack.prototype.toString = function() {
       return this.items.join(' ');
     }
   }
   ```

### 二、队列

1. 特点：先进先出（FIFO）

2. 实现：

   ```js
   function Queue() {
     this.items = [];
     // 向队列添加元素
     Queue.prototype.enqueue = function(element) {
       this.items.push(element);
     }
     // 元素出队
     Queue.prototype.dequeue = function() {
       return this.items.shift();
     }
     // 返回队列第一个元素
     Queue.prototype.front = function() {
       return this.items[0];
     }
     // 判断队列是否为空
     Queue.prototype.isEmpty = function() {
       return this.items.length === 0;
     }
     // 返回队列长度
     Queue.prototype.size = function() {
       return this.items.length;
     }
     // 将队列以字符串形式返回
     Queue.prototype.toString = function() {
       return this.items.join(' ');
     }
   }
   ```

   ​

### 三、优先级队列

1. 在队列的基础下，插入时判断元素的优先级，插入正确的位置

2. 实现：

   ```js
   function priorityQueue() {
     this.items = [];
     // 内部类
     function QueueElement(element, priority) {
       this.element = element;
       this.priority = priority;
     }
     // 入队
     priorityQueue.prototype.enqueue = function(element, priority) {
       const queueElement = new QueueElement(element, priority);
       if (this.items.length === 0) {
         this.items.push(queueElement);
       } else {
         let added = false;
         for (const i = 0;i < this.items.length; i++) {
           if (this.items[i].priority < queueElement.priority) {
             this.items.splice(i, 0, queueElement);
             added = true;
             break;
           }
         }
         if (!added) {
           this.items.push(queueElement);
         }
       }
     }
     // 出队
     priorityQueue.prototype.dequeue = function() {
       return this.items.shift();
     }
     // 返回队列第一个元素
     priorityQueue.prototype.front = function() {
       return this.items[0];
     }
     // 判断队列是否为空
     priorityQueue.prototype.isEmpty = function() {
       return this.items.length === 0;
     }
     // 返回队列长度
     priorityQueue.prototype.size = function() {
       return this.items.length;
     }
     // 将队列以字符串形式返回
     priorityQueue.prototype.toString = function() {
       return this.items.reduce(
         (pre, current, index) => {
           return pre + `${index === 0 ? '' : ' '}` + current.element, '');
         }
     }
   }
   ```

### 四、链表

- 单向链表

  1. 链表具有头部指针，每个item存放当前元素和next(指向下一个元素)，最后一个元素的next指向null

  2. 实现：

     ```js
     function LinkList() {
       // 首部指针
       this.head = null;
       this.length = 0;
       // 定义内部节点类
       function Node(element) {
         this.element = element;
         this.next = null;
       }
       // 向链表末尾添加元素
       LinkList.prototype.append = function(element) {
         const node = new Node(element);
         if (this.head === null) {
           this.head = node;
         } else {
           let current = this.head;
           while(current.next) {
             current = current.next;
           }
           current.next = node;
         }
         this.length++;
       }
       // 插入指定位置
       LinkList.prototype.insert = function(position, element) {
         const node = new Node(element);
         let current = this.head;
         let pre = null;
         let index = 0;
         if (position < 0 || position > this.length) {
           throw new Error('error');
         } else if (position === 0) {
           this.head = node;
           node.next = current;
         } else {
           while(index++ < position) {
             pre = current;
             current = current.next;
           }
           pre.next = node;
           node.next = current;
         }
         this.length++;
       }
       // 获取指定位置元素
       LinkList.prototype.get = function(position) {
         let current = this.head;
         let index = 0;
         if (position < 0 || position >= this.length) {
           throw new Error('position error');
         }
         while(index < position) {
           current = current.next;
           index++;
         }
         return current.element;
       }
       // 获取指定元素索引
       LinkList.prototype.indexOf = function(element) {
         let current = this.head;
         let index = 0;
         while(current) {
           if (element === current.element) {
             return index;
           }
           current = current.next;
           index++;
         }
         return -1;
       }
       // 更新指定位置元素
       LinkList.prototype.update = function(position, element) {
         let current = this.head;
         let index = 0;
         if (position < 0 || position >= this.length) {
           throw new Error('error');
         } 
         while(index++ < position) {
           current = current.next;
         }
         current.element = element;
         return true;
       }
       // 移除指定位置的元素
       LinkList.prototype.removeAt = function(position) {
         let current = this.head;
         let pre = null;
         let index = 0;
         if (position < 0 || position >= this.length) {
           throw new Error('error');
         }
         if (position === 0) {
           this.head = this.head.next;
           return true;
         }
         while(index++ < position) {
           pre = current;
           current = current.next;
         }
         pre.next = current.next;
         this.length--;
         return current.element;
       }
       // 移除元素
       LinkList.prototype.remove = function(element) {
         let position = this.indexOf(element);
         return this.removeAt(position);
       }
       LinkList.prototype.isEmpty = function() {
         return this.length === 0;
       }
       LinkList.prototype.size = function() {
         return this.length;
       }
       LinkList.prototype.toString = function() {
         let current = this.head;
         let result = '';
         if (this.head === null) return '';
         while(current) {
           result += result === '' ? current.element : ` ${current.element}`;
           current = current.next;
         }
         return result;
       }
     }
     ```

     ​

- 双向链表

1. 双向链表比单向链表多了一个尾指针，并且每个节点有一个pre值指向上一个节点

2. 实现：

   ```js
   function DoubleLinkList() {
     this.head = null;
     this.tail = null;
     this.length = 0;
     function Node(element) {
       this.element = element;
       this.prev = null;
       this.next = null;
     }
     DoubleLinkList.prototype.append = function(element) {
       const newNode = new Node(element);
       if (this.length === 0) {
         this.head = newNode;
         this.tail = newNode;
       } else {
         newNode.prev = this.tail;
         this.tail.next = newNode;
         this.tail = newNode;
       }
       this.length++;
     }
     DoubleLinkList.prototype.insert = function(position, element) {
       const newNode = new Node(element);

       if (position < 0 || position > this.length) {
         throw new Error('position error!');
       }
       if (this.length === 0) {
         this.head = newNode;
         this.tail = newNode;
       } else{
         if (position === 0) {
           this.head.prev = newNode;
           newNode.next = this.head;
           this.head = newNode;
         } else if (position === this.length) {
           newNode.prev = this.tail;
           this.tail.next = newNode;
           this.tail = newNode;
         } else {
           let current = this.head;
           let index = 0;
           while(index++ < position) {
             current = current.next;
           }
           newNode.prev = current.prev;
           newNode.next = current;
           current.prev.next = newNode;
           current.prev = newNode;
         }
       }
       this.length++;
       return true;
     }
     DoubleLinkList.prototype.get = function(position) {
       let index = 0;
       let current = null;
       if (position < 0 || position >= this.length) {
         throw new Error('position error!');
       }
       if (position < this.length / 2) {
         current = this.head;
         while(index++ < position) {
           current = current.next;
         }
       } else {
         current = this.tail;
         index = this.length - 1;
         while(index-- > position) {
           current = current.prev;
         }
       }
       return current.element;
     }
     DoubleLinkList.prototype.indexOf = function(element) {
       let current = this.head;
       let index = 0;
       while(current) {
         if (current.element === element) {
           return index;
         }
         current = current.next;
         index++;
       }
       return -1;
     }
     DoubleLinkList.prototype.update = function(position, element) {
       let index = 0;
       let current = null;
       if (position < 0 || position >= this.length) {
         throw new Error('position error!');
       }
       if (position < this.length / 2) {
         current = this.head;
         while(index++ < position) {
           current = current.next;
         }
       } else {
         current = this.tail;
         index = this.length - 1;
         while(index-- > position) {
           current = current.prev;
         }
       }
       current.element = element;
       return true;
     }
     DoubleLinkList.prototype.removeAt = function(position, element) {
       if (position < 0 || position >= this.length) {
         throw new Error('position error!');
       }

       if (this.length === 1) {
         this.head = null;
         this.tail = null;
       } else {
         let index = 0
         let current = null;
         if (position === 0) {
           this.head = this.head.next;
           this.head.prev = null;
         } else if(position === this.length -1) {
           this.tail = this.tail.prev;
           this.tail.next = null;
         } else {
           if (position < this.length / 2) {
             current = this.head;
             while(index++ < position) {
               current = current.next;
             }
           } else {
             index = this.length - 1;
             current = this.tail;
             while(index-- > position) {
               current = current.prev;
             }
           }
           current.prev.next = current.next;
           current.next.prev = current.prev;
         }
       }
       this.length--;
       return true;
     }
     DoubleLinkList.prototype.remove = function(element) {
       const index = this.indexOf(element);
       return this.removeAt(index);
     }
     DoubleLinkList.prototype.size = function() {
       return this.length;
     }
     DoubleLinkList.prototype.isEmpty = function() {
       return this.length === 0;
     }
     DoubleLinkList.prototype.forwardString = function() {
       let current = this.head;
       let result = '';
       while(current) {
         result += result === '' ? current.element : ` ${current.element}`;
         current = current.next;
       }
       return result;
     }
     DoubleLinkList.prototype.backwordString = function() {
       let current = this.tail;
       let result = '';
       while(current) {
         result += result === '' ? current.element : ` ${current.element}`;
         current = current.prev;
       }
       return result;
     }
   }
   ```

### 五、树

