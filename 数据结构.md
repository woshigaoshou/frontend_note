### 四、链表

- 单向链表

  1. 链表具有头部指针，每个item存放当前元素和next(指向下一个元素)，最后一个元素的next指向null

  2. 实现：

     ```js
     function LinkList() {
       // 首部指针
       this.head = null;
       this.length = 0;
       // 定义内部节点类
       function Node(element) {
         this.element = element;
         this.next = null;
       }
       // 向链表末尾添加元素
       LinkList.prototype.append = function(element) {
         const node = new Node(element);
         if (this.head === null) {
           this.head = node;
         } else {
           let current = this.head;
           while(current.next) {
             current = current.next;
           }
           current.next = node;
         }
         this.length++;
       }
       // 插入指定位置
       LinkList.prototype.insert = function(position, element) {
         const node = new Node(element);
         let current = this.head;
         let pre = null;
         let index = 0;
         if (position < 0 || position > this.length) {
           throw new Error('error');
         } else if (position === 0) {
           this.head = node;
           node.next = current;
         } else {
           while(index++ < position) {
             pre = current;
             current = current.next;
           }
           pre.next = node;
           node.next = current;
         }
         this.length++;
       }
       // 获取指定位置元素
       LinkList.prototype.get = function(position) {
         let current = this.head;
         let index = 0;
         if (position < 0 || position >= this.length) {
           throw new Error('position error');
         }
         while(index < position) {
           current = current.next;
           index++;
         }
         return current.element;
       }
       // 获取指定元素索引
       LinkList.prototype.indexOf = function(element) {
         let current = this.head;
         let index = 0;
         while(current) {
           if (element === current.element) {
             return index;
           }
           current = current.next;
           index++;
         }
         return -1;
       }
       // 更新指定位置元素
       LinkList.prototype.update = function(position, element) {
         let current = this.head;
         let index = 0;
         if (position < 0 || position >= this.length) {
           throw new Error('error');
         } 
         while(index++ < position) {
           current = current.next;
         }
         current.element = element;
         return true;
       }
       // 移除指定位置的元素
       LinkList.prototype.removeAt = function(position) {
         let current = this.head;
         let pre = null;
         let index = 0;
         if (position < 0 || position >= this.length) {
           throw new Error('error');
         }
         if (position === 0) {
           this.head = this.head.next;
           return true;
         }
         while(index++ < position) {
           pre = current;
           current = current.next;
         }
         pre.next = current.next;
         this.length--;
         return current.element;
       }
       // 移除元素
       LinkList.prototype.remove = function(element) {
         let position = this.indexOf(element);
         return this.removeAt(position);
       }
       LinkList.prototype.isEmpty = function() {
         return this.length === 0;
       }
       LinkList.prototype.size = function() {
         return this.length;
       }
       LinkList.prototype.toString = function() {
         let current = this.head;
         let result = '';
         if (this.head === null) return '';
         while(current) {
           result += result === '' ? current.element : ` ${current.element}`;
           current = current.next;
         }
         return result;
       }
     }
     ```

     ​

- 双向链表

1. 双向链表比单向链表多了一个尾指针，并且每个节点有一个pre值指向上一个节点

2. 实现：

   ```js
   function DoubleLinkList() {
     this.head = null;
     this.tail = null;
     this.length = 0;
     function Node(element) {
       this.element = element;
       this.prev = null;
       this.next = null;
     }
     DoubleLinkList.prototype.append = function(element) {
       const newNode = new Node(element);
       if (this.length === 0) {
         this.head = newNode;
         this.tail = newNode;
       } else {
         newNode.prev = this.tail;
         this.tail.next = newNode;
         this.tail = newNode;
       }
       this.length++;
     }
     DoubleLinkList.prototype.insert = function(position, element) {
       const newNode = new Node(element);

       if (position < 0 || position > this.length) {
         throw new Error('position error!');
       }
       if (this.length === 0) {
         this.head = newNode;
         this.tail = newNode;
       } else{
         if (position === 0) {
           this.head.prev = newNode;
           newNode.next = this.head;
           this.head = newNode;
         } else if (position === this.length) {
           newNode.prev = this.tail;
           this.tail.next = newNode;
           this.tail = newNode;
         } else {
           let current = this.head;
           let index = 0;
           while(index++ < position) {
             current = current.next;
           }
           newNode.prev = current.prev;
           newNode.next = current;
           current.prev.next = newNode;
           current.prev = newNode;
         }
       }
       this.length++;
       return true;
     }
     DoubleLinkList.prototype.get = function(position) {
       let index = 0;
       let current = null;
       if (position < 0 || position >= this.length) {
         throw new Error('position error!');
       }
       if (position < this.length / 2) {
         current = this.head;
         while(index++ < position) {
           current = current.next;
         }
       } else {
         current = this.tail;
         index = this.length - 1;
         while(index-- > position) {
           current = current.prev;
         }
       }
       return current.element;
     }
     DoubleLinkList.prototype.indexOf = function(element) {
       let current = this.head;
       let index = 0;
       while(current) {
         if (current.element === element) {
           return index;
         }
         current = current.next;
         index++;
       }
       return -1;
     }
     DoubleLinkList.prototype.update = function(position, element) {
       let index = 0;
       let current = null;
       if (position < 0 || position >= this.length) {
         throw new Error('position error!');
       }
       if (position < this.length / 2) {
         current = this.head;
         while(index++ < position) {
           current = current.next;
         }
       } else {
         current = this.tail;
         index = this.length - 1;
         while(index-- > position) {
           current = current.prev;
         }
       }
       current.element = element;
       return true;
     }
     DoubleLinkList.prototype.removeAt = function(position, element) {
       if (position < 0 || position >= this.length) {
         throw new Error('position error!');
       }

       if (this.length === 1) {
         this.head = null;
         this.tail = null;
       } else {
         let index = 0
         let current = null;
         if (position === 0) {
           this.head = this.head.next;
           this.head.prev = null;
         } else if(position === this.length -1) {
           this.tail = this.tail.prev;
           this.tail.next = null;
         } else {
           if (position < this.length / 2) {
             current = this.head;
             while(index++ < position) {
               current = current.next;
             }
           } else {
             index = this.length - 1;
             current = this.tail;
             while(index-- > position) {
               current = current.prev;
             }
           }
           current.prev.next = current.next;
           current.next.prev = current.prev;
         }
       }
       this.length--;
       return true;
     }
     DoubleLinkList.prototype.remove = function(element) {
       const index = this.indexOf(element);
       return this.removeAt(index);
     }
     DoubleLinkList.prototype.size = function() {
       return this.length;
     }
     DoubleLinkList.prototype.isEmpty = function() {
       return this.length === 0;
     }
     DoubleLinkList.prototype.forwardString = function() {
       let current = this.head;
       let result = '';
       while(current) {
         result += result === '' ? current.element : ` ${current.element}`;
         current = current.next;
       }
       return result;
     }
     DoubleLinkList.prototype.backwordString = function() {
       let current = this.tail;
       let result = '';
       while(current) {
         result += result === '' ? current.element : ` ${current.element}`;
         current = current.prev;
       }
       return result;
     }
   }
   ```

### 五、树